{"ast":null,"code":"'use strict';\n/**\n * Given a function fn that takes a callback as its last argument, returns\n * a new version of the function that takes the callback optionally. If\n * the function is not called with a callback for the last argument, the\n * function will return a promise instead.\n */\n\nfunction callbackToPromise(fn, context, callbackArgIndex) {\n  return function () {\n    var thisCallbackArgIndex;\n\n    if (callbackArgIndex === void 0) {\n      thisCallbackArgIndex = arguments.length > 0 ? arguments.length - 1 : 0;\n    } else {\n      thisCallbackArgIndex = callbackArgIndex;\n    }\n\n    var callbackArg = arguments[thisCallbackArgIndex];\n\n    if (typeof callbackArg === 'function') {\n      fn.apply(context, arguments);\n      return void 0;\n    } else {\n      var args = []; // If an explicit callbackArgIndex is set, but the function is called\n      // with too few arguments, we want to push undefined onto args so that\n      // our constructed callback ends up at the right index.\n\n      var argLen = Math.max(arguments.length, thisCallbackArgIndex);\n\n      for (var i = 0; i < argLen; i++) {\n        args.push(arguments[i]);\n      }\n\n      return new Promise(function (resolve, reject) {\n        args.push(function (err, result) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n        });\n        fn.apply(context, args);\n      });\n    }\n  };\n}\n\nmodule.exports = callbackToPromise;","map":{"version":3,"sources":["/Users/gauravsingh/Desktop/projects/Lucky-India/node_modules/airtable/lib/callback_to_promise.js"],"names":["callbackToPromise","fn","context","callbackArgIndex","thisCallbackArgIndex","arguments","length","callbackArg","apply","args","argLen","Math","max","i","push","Promise","resolve","reject","err","result","module","exports"],"mappings":"AAAA;AAEA;;;;;;;AAMA,SAASA,iBAAT,CAA2BC,EAA3B,EAA+BC,OAA/B,EAAwCC,gBAAxC,EAA0D;AACtD,SAAO,YAAW;AACd,QAAIC,oBAAJ;;AACA,QAAID,gBAAgB,KAAK,KAAK,CAA9B,EAAiC;AAC7BC,MAAAA,oBAAoB,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,GAAuBD,SAAS,CAACC,MAAV,GAAmB,CAA1C,GAA8C,CAArE;AACH,KAFD,MAEO;AACHF,MAAAA,oBAAoB,GAAGD,gBAAvB;AACH;;AACD,QAAII,WAAW,GAAGF,SAAS,CAACD,oBAAD,CAA3B;;AACA,QAAI,OAAOG,WAAP,KAAuB,UAA3B,EAAuC;AACnCN,MAAAA,EAAE,CAACO,KAAH,CAASN,OAAT,EAAkBG,SAAlB;AACA,aAAO,KAAK,CAAZ;AACH,KAHD,MAGO;AACH,UAAII,IAAI,GAAG,EAAX,CADG,CAEH;AACA;AACA;;AACA,UAAIC,MAAM,GAAGC,IAAI,CAACC,GAAL,CAASP,SAAS,CAACC,MAAnB,EAA2BF,oBAA3B,CAAb;;AACA,WAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAApB,EAA4BG,CAAC,EAA7B,EAAiC;AAC7BJ,QAAAA,IAAI,CAACK,IAAL,CAAUT,SAAS,CAACQ,CAAD,CAAnB;AACH;;AACD,aAAO,IAAIE,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AACzCR,QAAAA,IAAI,CAACK,IAAL,CAAU,UAASI,GAAT,EAAcC,MAAd,EAAsB;AAC5B,cAAID,GAAJ,EAAS;AACLD,YAAAA,MAAM,CAACC,GAAD,CAAN;AACH,WAFD,MAEO;AACHF,YAAAA,OAAO,CAACG,MAAD,CAAP;AACH;AACJ,SAND;AAOAlB,QAAAA,EAAE,CAACO,KAAH,CAASN,OAAT,EAAkBO,IAAlB;AACH,OATM,CAAP;AAUH;AACJ,GA/BD;AAgCH;;AAEDW,MAAM,CAACC,OAAP,GAAiBrB,iBAAjB","sourcesContent":["'use strict';\n\n/**\n * Given a function fn that takes a callback as its last argument, returns\n * a new version of the function that takes the callback optionally. If\n * the function is not called with a callback for the last argument, the\n * function will return a promise instead.\n */\nfunction callbackToPromise(fn, context, callbackArgIndex) {\n    return function() {\n        var thisCallbackArgIndex;\n        if (callbackArgIndex === void 0) {\n            thisCallbackArgIndex = arguments.length > 0 ? arguments.length - 1 : 0;\n        } else {\n            thisCallbackArgIndex = callbackArgIndex;\n        }\n        var callbackArg = arguments[thisCallbackArgIndex];\n        if (typeof callbackArg === 'function') {\n            fn.apply(context, arguments);\n            return void 0;\n        } else {\n            var args = [];\n            // If an explicit callbackArgIndex is set, but the function is called\n            // with too few arguments, we want to push undefined onto args so that\n            // our constructed callback ends up at the right index.\n            var argLen = Math.max(arguments.length, thisCallbackArgIndex);\n            for (var i = 0; i < argLen; i++) {\n                args.push(arguments[i]);\n            }\n            return new Promise(function(resolve, reject) {\n                args.push(function(err, result) {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(result);\n                    }\n                });\n                fn.apply(context, args);\n            });\n        }\n    };\n}\n\nmodule.exports = callbackToPromise;\n"]},"metadata":{},"sourceType":"script"}