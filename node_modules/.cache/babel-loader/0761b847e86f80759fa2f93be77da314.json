{"ast":null,"code":"'use strict';\n\nvar isPlainObject = require('lodash/isPlainObject');\n\nvar isFunction = require('lodash/isFunction');\n\nvar isString = require('lodash/isString');\n\nvar isNumber = require('lodash/isNumber');\n\nvar includes = require('lodash/includes');\n\nvar clone = require('lodash/clone');\n\nvar forEach = require('lodash/forEach');\n\nvar map = require('lodash/map');\n\nvar keys = require('lodash/keys');\n\nvar check = require('./typecheck');\n\nvar Record = require('./record');\n\nvar callbackToPromise = require('./callback_to_promise');\n\nvar has = require('./has');\n/**\n * Builds a query object. Won't fetch until `firstPage` or\n * or `eachPage` is called.\n *\n * Params should be validated prior to being passed to Query\n * with `Query.validateParams`.\n */\n\n\nfunction Query(table, params) {\n  this._table = table;\n  this._params = params;\n  this.firstPage = callbackToPromise(firstPage, this);\n  this.eachPage = callbackToPromise(eachPage, this, 1);\n  this.all = callbackToPromise(all, this);\n}\n/**\n * Fetches the first page of results for the query asynchronously,\n * then calls `done(error, records)`.\n */\n\n\nfunction firstPage(done) {\n  if (!isFunction(done)) {\n    throw new Error('The first parameter to `firstPage` must be a function');\n  }\n\n  this.eachPage(function (records) {\n    done(null, records);\n  }, function (error) {\n    done(error, null);\n  });\n}\n/**\n * Fetches each page of results for the query asynchronously.\n *\n * Calls `pageCallback(records, fetchNextPage)` for each\n * page. You must call `fetchNextPage()` to fetch the next page of\n * results.\n *\n * After fetching all pages, or if there's an error, calls\n * `done(error)`.\n */\n\n\nfunction eachPage(pageCallback, done) {\n  if (!isFunction(pageCallback)) {\n    throw new Error('The first parameter to `eachPage` must be a function');\n  }\n\n  if (!isFunction(done) && done !== void 0) {\n    throw new Error('The second parameter to `eachPage` must be a function or undefined');\n  }\n\n  var that = this;\n\n  var path = '/' + this._table._urlEncodedNameOrId();\n\n  var params = clone(this._params);\n\n  var inner = function () {\n    that._table._base.runAction('get', path, params, null, function (err, response, result) {\n      if (err) {\n        done(err, null);\n      } else {\n        var next;\n\n        if (result.offset) {\n          params.offset = result.offset;\n          next = inner;\n        } else {\n          next = function () {\n            done(null);\n          };\n        }\n\n        var records = map(result.records, function (recordJson) {\n          return new Record(that._table, null, recordJson);\n        });\n        pageCallback(records, next);\n      }\n    });\n  };\n\n  inner();\n}\n/**\n * Fetches all pages of results asynchronously. May take a long time.\n */\n\n\nfunction all(done) {\n  if (!isFunction(done)) {\n    throw new Error('The first parameter to `all` must be a function');\n  }\n\n  var allRecords = [];\n  this.eachPage(function (pageRecords, fetchNextPage) {\n    allRecords.push.apply(allRecords, pageRecords);\n    fetchNextPage();\n  }, function (err) {\n    if (err) {\n      done(err, null);\n    } else {\n      done(null, allRecords);\n    }\n  });\n}\n\nQuery.paramValidators = {\n  fields: check(check.isArrayOf(isString), 'the value for `fields` should be an array of strings'),\n  filterByFormula: check(isString, 'the value for `filterByFormula` should be a string'),\n  maxRecords: check(isNumber, 'the value for `maxRecords` should be a number'),\n  pageSize: check(isNumber, 'the value for `pageSize` should be a number'),\n  sort: check(check.isArrayOf(function (obj) {\n    return isPlainObject(obj) && isString(obj.field) && (obj.direction === void 0 || includes(['asc', 'desc'], obj.direction));\n  }), 'the value for `sort` should be an array of sort objects. ' + 'Each sort object must have a string `field` value, and an optional ' + '`direction` value that is \"asc\" or \"desc\".'),\n  view: check(isString, 'the value for `view` should be a string'),\n  cellFormat: check(function (cellFormat) {\n    return isString(cellFormat) && includes(['json', 'string'], cellFormat);\n  }, 'the value for `cellFormat` should be \"json\" or \"string\"'),\n  timeZone: check(isString, 'the value for `timeZone` should be a string'),\n  userLocale: check(isString, 'the value for `userLocale` should be a string')\n};\n/**\n * Validates the parameters for passing to the Query constructor.\n *\n * @params {object} params parameters to validate\n *\n * @return an object with two keys:\n *  validParams: the object that should be passed to the constructor.\n *  ignoredKeys: a list of keys that will be ignored.\n *  errors: a list of error messages.\n */\n\nQuery.validateParams = function validateParams(params) {\n  var validParams = {};\n  var ignoredKeys = [];\n  var errors = [];\n  forEach(keys(params), function (key) {\n    var value = params[key];\n\n    if (has(Query.paramValidators, key)) {\n      var validator = Query.paramValidators[key];\n      var validationResult = validator(value);\n\n      if (validationResult.pass) {\n        validParams[key] = value;\n      } else {\n        errors.push(validationResult.error);\n      }\n    } else {\n      ignoredKeys.push(key);\n    }\n  });\n  return {\n    validParams: validParams,\n    ignoredKeys: ignoredKeys,\n    errors: errors\n  };\n};\n\nmodule.exports = Query;","map":{"version":3,"sources":["/Users/gauravsingh/Desktop/projects/Lucky-India/node_modules/airtable/lib/query.js"],"names":["isPlainObject","require","isFunction","isString","isNumber","includes","clone","forEach","map","keys","check","Record","callbackToPromise","has","Query","table","params","_table","_params","firstPage","eachPage","all","done","Error","records","error","pageCallback","that","path","_urlEncodedNameOrId","inner","_base","runAction","err","response","result","next","offset","recordJson","allRecords","pageRecords","fetchNextPage","push","apply","paramValidators","fields","isArrayOf","filterByFormula","maxRecords","pageSize","sort","obj","field","direction","view","cellFormat","timeZone","userLocale","validateParams","validParams","ignoredKeys","errors","key","value","validator","validationResult","pass","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar isPlainObject = require('lodash/isPlainObject');\nvar isFunction = require('lodash/isFunction');\nvar isString = require('lodash/isString');\nvar isNumber = require('lodash/isNumber');\nvar includes = require('lodash/includes');\nvar clone = require('lodash/clone');\nvar forEach = require('lodash/forEach');\nvar map = require('lodash/map');\nvar keys = require('lodash/keys');\n\nvar check = require('./typecheck');\nvar Record = require('./record');\nvar callbackToPromise = require('./callback_to_promise');\nvar has = require('./has');\n\n/**\n * Builds a query object. Won't fetch until `firstPage` or\n * or `eachPage` is called.\n *\n * Params should be validated prior to being passed to Query\n * with `Query.validateParams`.\n */\nfunction Query(table, params) {\n    this._table = table;\n    this._params = params;\n\n    this.firstPage = callbackToPromise(firstPage, this);\n    this.eachPage = callbackToPromise(eachPage, this, 1);\n    this.all = callbackToPromise(all, this);\n}\n\n/**\n * Fetches the first page of results for the query asynchronously,\n * then calls `done(error, records)`.\n */\nfunction firstPage(done) {\n    if (!isFunction(done)) {\n        throw new Error('The first parameter to `firstPage` must be a function');\n    }\n\n    this.eachPage(\n        function(records) {\n            done(null, records);\n        },\n        function(error) {\n            done(error, null);\n        }\n    );\n}\n\n/**\n * Fetches each page of results for the query asynchronously.\n *\n * Calls `pageCallback(records, fetchNextPage)` for each\n * page. You must call `fetchNextPage()` to fetch the next page of\n * results.\n *\n * After fetching all pages, or if there's an error, calls\n * `done(error)`.\n */\nfunction eachPage(pageCallback, done) {\n    if (!isFunction(pageCallback)) {\n        throw new Error('The first parameter to `eachPage` must be a function');\n    }\n\n    if (!isFunction(done) && done !== void 0) {\n        throw new Error('The second parameter to `eachPage` must be a function or undefined');\n    }\n\n    var that = this;\n    var path = '/' + this._table._urlEncodedNameOrId();\n    var params = clone(this._params);\n\n    var inner = function() {\n        that._table._base.runAction('get', path, params, null, function(err, response, result) {\n            if (err) {\n                done(err, null);\n            } else {\n                var next;\n                if (result.offset) {\n                    params.offset = result.offset;\n                    next = inner;\n                } else {\n                    next = function() {\n                        done(null);\n                    };\n                }\n\n                var records = map(result.records, function(recordJson) {\n                    return new Record(that._table, null, recordJson);\n                });\n\n                pageCallback(records, next);\n            }\n        });\n    };\n\n    inner();\n}\n\n/**\n * Fetches all pages of results asynchronously. May take a long time.\n */\nfunction all(done) {\n    if (!isFunction(done)) {\n        throw new Error('The first parameter to `all` must be a function');\n    }\n\n    var allRecords = [];\n    this.eachPage(\n        function(pageRecords, fetchNextPage) {\n            allRecords.push.apply(allRecords, pageRecords);\n            fetchNextPage();\n        },\n        function(err) {\n            if (err) {\n                done(err, null);\n            } else {\n                done(null, allRecords);\n            }\n        }\n    );\n}\n\nQuery.paramValidators = {\n    fields: check(\n        check.isArrayOf(isString),\n        'the value for `fields` should be an array of strings'\n    ),\n\n    filterByFormula: check(isString, 'the value for `filterByFormula` should be a string'),\n\n    maxRecords: check(isNumber, 'the value for `maxRecords` should be a number'),\n\n    pageSize: check(isNumber, 'the value for `pageSize` should be a number'),\n\n    sort: check(\n        check.isArrayOf(function(obj) {\n            return (\n                isPlainObject(obj) &&\n                isString(obj.field) &&\n                (obj.direction === void 0 || includes(['asc', 'desc'], obj.direction))\n            );\n        }),\n        'the value for `sort` should be an array of sort objects. ' +\n            'Each sort object must have a string `field` value, and an optional ' +\n            '`direction` value that is \"asc\" or \"desc\".'\n    ),\n\n    view: check(isString, 'the value for `view` should be a string'),\n\n    cellFormat: check(function(cellFormat) {\n        return isString(cellFormat) && includes(['json', 'string'], cellFormat);\n    }, 'the value for `cellFormat` should be \"json\" or \"string\"'),\n\n    timeZone: check(isString, 'the value for `timeZone` should be a string'),\n\n    userLocale: check(isString, 'the value for `userLocale` should be a string'),\n};\n\n/**\n * Validates the parameters for passing to the Query constructor.\n *\n * @params {object} params parameters to validate\n *\n * @return an object with two keys:\n *  validParams: the object that should be passed to the constructor.\n *  ignoredKeys: a list of keys that will be ignored.\n *  errors: a list of error messages.\n */\nQuery.validateParams = function validateParams(params) {\n    var validParams = {};\n    var ignoredKeys = [];\n    var errors = [];\n\n    forEach(keys(params), function(key) {\n        var value = params[key];\n        if (has(Query.paramValidators, key)) {\n            var validator = Query.paramValidators[key];\n            var validationResult = validator(value);\n            if (validationResult.pass) {\n                validParams[key] = value;\n            } else {\n                errors.push(validationResult.error);\n            }\n        } else {\n            ignoredKeys.push(key);\n        }\n    });\n\n    return {\n        validParams: validParams,\n        ignoredKeys: ignoredKeys,\n        errors: errors,\n    };\n};\n\nmodule.exports = Query;\n"]},"metadata":{},"sourceType":"script"}